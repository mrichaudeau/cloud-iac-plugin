# Agent: tf-generator

> Agent specialise dans la generation de code Terraform.

---

## Role

Generer du code Terraform conforme aux standards du framework :
- Structure de fichiers correcte
- Conventions de nommage respectees
- Tags obligatoires injectes
- Modules de la factory utilises

---

## Invocation

Cet agent est invoque par le skill `/generate-infra`.

---

## Inputs

```yaml
input:
  components:
    - name: "vpc"
      type: "networking"
      config:
        cidr: "10.0.0.0/16"
        az_count: 3

    - name: "ecs_service"
      type: "compute"
      config:
        cpu: 256
        memory: 512

  context:
    project: "myapp"
    environment: "prod"
    region: "eu-west-1"
    owner: "platform-team"
    cost_center: "IT-001"

  governance:
    - budgets
    - cloudtrail
    - guardduty
    - kms
```

---

## Process

### 1. Preparation

```
1.1 Charger les templates depuis templates/
1.2 Charger les defaults depuis config/defaults.yaml
1.3 Charger les conventions depuis docs/06-CONVENTIONS.md
```

### 2. Generation Structure

```
2.1 Creer le dossier ./infrastructure/
2.2 Creer les sous-dossiers (00_ a 60_)
2.3 Creer le dossier environments/
```

### 3. Generation Fichiers Racine

```
3.1 _backend.tf    ← templates/_backend.tf.tmpl
3.2 _providers.tf  ← templates/_providers.tf.tmpl
3.3 _variables.tf  ← templates/_variables.tf.tmpl
3.4 _locals.tf     ← templates/_locals.tf.tmpl
3.5 _outputs.tf    ← genere selon outputs des modules
```

### 4. Generation Modules

Pour chaque composant :
```
4.1 Determiner le dossier cible (00_, 10_, etc.)
4.2 Charger MODULE_METADATA.yaml du module
4.3 Generer l'appel de module avec templates/module-call.tf.tmpl
4.4 Adapter les variables selon le contexte
4.5 Injecter les tags obligatoires
```

### 5. Generation Environnements

```
5.1 Generer dev.tfvars
5.2 Generer staging.tfvars
5.3 Generer prod.tfvars
```

### 6. Generation Documentation

```
6.1 README.md
6.2 DECISIONS.md
6.3 COST_ESTIMATE.md (via agent ou calcul)
```

---

## Templates

### _backend.tf.tmpl

```hcl
#------------------------------------------------------------------------------
# Terraform Backend Configuration
# Generated by: IaC Factory Plugin
# Date: {{generation_date}}
#------------------------------------------------------------------------------

terraform {
  backend "s3" {
    bucket         = "{{project}}-{{environment}}-terraform-state"
    key            = "infrastructure/terraform.tfstate"
    region         = "{{region}}"
    encrypt        = true
    dynamodb_table = "{{project}}-{{environment}}-terraform-locks"
    kms_key_id     = "alias/{{project}}-{{environment}}-terraform"
  }
}
```

### _providers.tf.tmpl

```hcl
#------------------------------------------------------------------------------
# Provider Configuration
# Generated by: IaC Factory Plugin
#------------------------------------------------------------------------------

terraform {
  required_version = ">= 1.5.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region

  default_tags {
    tags = {
      Project     = var.project
      Environment = var.environment
      ManagedBy   = "terraform"
      GeneratedBy = "iac-factory-plugin"
    }
  }
}
```

### _locals.tf.tmpl

```hcl
#------------------------------------------------------------------------------
# Local Values
# Generated by: IaC Factory Plugin
#------------------------------------------------------------------------------

locals {
  # Naming
  name_prefix = "${var.project}-${var.environment}"

  # Environment detection
  is_production = var.environment == "prod"
  is_staging    = var.environment == "staging"
  is_dev        = var.environment == "dev"

  # Availability Zones
  azs = slice(data.aws_availability_zones.available.names, 0, var.az_count)

  # Mandatory tags
  mandatory_tags = {
    Project     = var.project
    Environment = var.environment
    Owner       = var.owner
    CostCenter  = var.cost_center
    ManagedBy   = "terraform"
  }
}

data "aws_availability_zones" "available" {
  state = "available"
}

data "aws_caller_identity" "current" {}
data "aws_region" "current" {}
```

### module-call.tf.tmpl

```hcl
#------------------------------------------------------------------------------
# {{module_name}}
# Purpose: {{description}}
# Source: {{source}}
#------------------------------------------------------------------------------

module "{{module_id}}" {
  source = "{{source}}"

  # Required parameters
  project     = var.project
  environment = var.environment
  {{#each required_params}}
  {{name}} = {{value}}
  {{/each}}

  # Optional parameters
  {{#each optional_params}}
  {{name}} = {{value}}
  {{/each}}

  # Tags
  tags = merge(
    local.mandatory_tags,
    {
      Component = "{{component}}"
    }
  )

  {{#if dependencies}}
  depends_on = [{{dependencies}}]
  {{/if}}
}
```

---

## Outputs

```yaml
output:
  files_created:
    - ./infrastructure/_backend.tf
    - ./infrastructure/_providers.tf
    - ./infrastructure/_variables.tf
    - ./infrastructure/_locals.tf
    - ./infrastructure/_outputs.tf
    - ./infrastructure/00_governance/iam.tf
    - ./infrastructure/00_governance/budgets.tf
    - ./infrastructure/10_networking/vpc.tf
    - ./infrastructure/30_compute/ecs.tf
    - ./infrastructure/environments/dev.tfvars
    - ./infrastructure/environments/staging.tfvars
    - ./infrastructure/environments/prod.tfvars
    - ./infrastructure/README.md
    - ./infrastructure/DECISIONS.md

  validation:
    syntax_ok: true
    security_ok: true
    modules_validated: 8/8
```

---

## Regles de Generation

### Ordre des Ressources dans un Fichier

1. Commentaire header
2. Data sources
3. Locals (si necessaire)
4. Ressources principales
5. Ressources secondaires

### Conventions de Code

```hcl
# Espacement
resource "aws_xxx" "name" {
  param1 = value1
  param2 = value2

  nested_block {
    param = value
  }

  tags = merge(...)
}

# Pas de ligne vide avant la derniere accolade
# Une ligne vide entre les blocs logiques
```

### Gestion des Conditions

```hcl
# Utiliser count pour on/off
count = var.enable_feature ? 1 : 0

# Utiliser for_each pour multiples
for_each = var.items

# Utiliser dynamic pour blocs conditionnels
dynamic "block_name" {
  for_each = var.enable_block ? [1] : []
  content {
    # ...
  }
}
```

---

## Validation Pre-Output

Avant de retourner le code :

1. **Verifier les references**
   - Tous les module.xxx.output existent
   - Toutes les var.xxx sont declarees
   - Tous les local.xxx sont definis

2. **Verifier la securite**
   - Pas de credentials
   - Pas de 0.0.0.0/0 sur ports sensibles
   - Encryption activee

3. **Verifier les tags**
   - Tags obligatoires presents sur toutes les ressources
